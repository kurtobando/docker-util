
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bw_util/internal/app/app.go (2.0%)</option>
				
				<option value="file1">bw_util/internal/config/config.go (100.0%)</option>
				
				<option value="file2">bw_util/internal/database/repository.go (88.7%)</option>
				
				<option value="file3">bw_util/internal/database/sqlite.go (80.8%)</option>
				
				<option value="file4">bw_util/internal/docker/client.go (91.3%)</option>
				
				<option value="file5">bw_util/internal/docker/collector.go (6.6%)</option>
				
				<option value="file6">bw_util/internal/docker/parser.go (100.0%)</option>
				
				<option value="file7">bw_util/internal/testutil/database.go (88.9%)</option>
				
				<option value="file8">bw_util/internal/testutil/fixtures.go (100.0%)</option>
				
				<option value="file9">bw_util/internal/testutil/mocks.go (64.9%)</option>
				
				<option value="file10">bw_util/internal/web/handlers.go (100.0%)</option>
				
				<option value="file11">bw_util/internal/web/server.go (81.2%)</option>
				
				<option value="file12">bw_util/internal/web/templates.go (75.0%)</option>
				
				<option value="file13">bw_util/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "context"
        "embed"
        "log"
        "os"
        "os/signal"
        "syscall"

        "bw_util/internal/config"
        "bw_util/internal/database"
        "bw_util/internal/docker"
        "bw_util/internal/web"
)

// App represents the main application
type App struct {
        config          *config.Config
        db              *database.Database
        repository      *database.Repository
        dockerClient    *docker.Client
        collector       *docker.Collector
        templateManager *web.TemplateManager
        handler         *web.Handler
        server          *web.Server
        templatesFS     embed.FS
}

// New creates a new application instance
func New(templatesFS embed.FS) *App <span class="cov8" title="1">{
        return &amp;App{
                templatesFS: templatesFS,
        }
}</span>

// Initialize sets up all application components
// This preserves the exact same initialization logic from the original main function
func (a *App) Initialize() error <span class="cov0" title="0">{
        // Load configuration
        a.config = config.Load()

        // Initialize database
        a.db = database.NewDatabase(a.config.DBPath)
        if err := a.db.Connect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create repository
        <span class="cov0" title="0">a.repository = database.NewRepository(a.db)

        // Initialize template manager
        a.templateManager = web.NewTemplateManager(a.templatesFS)
        if err := a.templateManager.LoadTemplates(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create web components
        <span class="cov0" title="0">a.handler = web.NewHandler(a.repository, a.templateManager, a.config.DBPath)
        a.server = web.NewServer(a.config.ServerPort, a.handler)

        // Initialize Docker client
        var err error
        a.dockerClient, err = docker.NewClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error creating Docker client (log collection might not work): %v", err)
                // Decide if this is fatal. For now, web UI might still work with existing DB data.
                return nil // Continue without Docker client
        }</span>

        // Create log collector
        <span class="cov0" title="0">a.collector = docker.NewCollector(a.dockerClient, a.repository)

        return nil</span>
}

// Run starts the application and handles the main execution loop
// This preserves the exact same execution logic from the original main function
func (a *App) Run() error <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutdown signal received, initiating graceful shutdown...")
                cancel()
        }</span>()

        // Start Docker log collection if Docker client is available
        <span class="cov0" title="0">if a.dockerClient != nil </span><span class="cov0" title="0">{
                containers, err := a.dockerClient.ListRunningContainers(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                                log.Println("Context cancelled during container listing.")
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Error listing containers (log collection might be impacted): %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := a.collector.StartCollection(ctx, containers); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error starting log collection: %v", err)
                        }</span>
                }
        }

        // Start web server
        <span class="cov0" title="0">if err := a.server.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Wait for shutdown signal
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Shutdown web server
        if err := a.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error shutting down web server: %v", err)
        }</span>

        // Wait for log streaming goroutines to finish
        <span class="cov0" title="0">if a.collector != nil </span><span class="cov0" title="0">{
                log.Println("Waiting for log streaming goroutines to finish...")
                a.collector.Wait()
        }</span>

        // Close resources
        <span class="cov0" title="0">log.Println("All goroutines finished. Closing resources.")
        if a.db != nil </span><span class="cov0" title="0">{
                if err := a.db.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing database: %v\n", err)
                }</span>
        }
        <span class="cov0" title="0">if a.dockerClient != nil </span><span class="cov0" title="0">{
                if err := a.dockerClient.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing Docker client: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Application shut down gracefully.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import "flag"

// Config holds all application configuration
type Config struct {
        DBPath     string
        ServerPort string
}

// Load parses command line flags and returns configuration
// This preserves the exact same flags and defaults from the original main.go
func Load() *Config <span class="cov8" title="1">{
        config := &amp;Config{}

        flag.StringVar(&amp;config.DBPath, "dbpath", "./docker_logs.db", "Path to the SQLite database file.")
        flag.StringVar(&amp;config.ServerPort, "port", "9123", "Port for the web UI.")

        flag.Parse()

        return config
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "fmt"
        "log"
        "strings"

        "bw_util/internal/models"
)

// LogRepository defines the interface for log database operations
type LogRepository interface {
        Store(ctx context.Context, entry *models.LogEntry) error
        Search(ctx context.Context, params *models.SearchParams) ([]models.LogEntry, bool, error)
        GetContainers(ctx context.Context) ([]string, error)
}

// Repository implements LogRepository
type Repository struct {
        db *Database
}

// NewRepository creates a new repository instance
func NewRepository(db *Database) *Repository <span class="cov8" title="1">{
        return &amp;Repository{db: db}
}</span>

// Store inserts a log entry into the database
// This preserves the exact same retry logic from the original streamAndStoreLogs function
func (r *Repository) Store(ctx context.Context, entry *models.LogEntry) error <span class="cov8" title="1">{
        // Retry logic for database insertion (from original code)
        for i := 0; i &lt; 3; i++ </span><span class="cov8" title="1">{ // Try up to 3 times
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">stmt, err := r.db.GetDB().PrepareContext(ctx, "INSERT INTO logs(container_id, container_name, timestamp, stream_type, log_message) VALUES(?, ?, ?, ?, ?)")
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Error preparing SQL statement (attempt %d): %v\n", i+1, err)
                        if i == 2 </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to prepare statement after 3 attempts: %w", err)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">_, execErr := stmt.ExecContext(ctx, entry.ContainerID, entry.ContainerName, entry.Timestamp, entry.StreamType, entry.LogMessage)
                stmt.Close() // Close statement after exec or on error

                if execErr == nil </span><span class="cov8" title="1">{
                        return nil // Success
                }</span>

                <span class="cov8" title="1">log.Printf("Error inserting log into DB (attempt %d): %v. Log: %.50s...", i+1, execErr, entry.LogMessage)
                if i == 2 </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to insert log after 3 attempts: %w", execErr)
                }</span>

                // Check if the error is context cancellation
                <span class="cov8" title="1">if execErr.Error() == context.Canceled.Error() || execErr.Error() == context.DeadlineExceeded.Error() </span><span class="cov0" title="0">{
                        return execErr
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Search retrieves logs based on search parameters
// This preserves the exact same query logic from the original serveLogsPage function
func (r *Repository) Search(ctx context.Context, params *models.SearchParams) ([]models.LogEntry, bool, error) <span class="cov8" title="1">{
        // Build SQL query conditionally based on search and container filters
        // Use LIMIT 101 to check if there's a next page (exact same logic as original)
        var query string
        var args []interface{}
        var whereConditions []string

        // Add container filter if specified
        if len(params.SelectedContainers) &gt; 0 </span><span class="cov8" title="1">{
                placeholders := make([]string, len(params.SelectedContainers))
                for i, container := range params.SelectedContainers </span><span class="cov8" title="1">{
                        placeholders[i] = "?"
                        args = append(args, container)
                }</span>
                <span class="cov8" title="1">whereConditions = append(whereConditions, fmt.Sprintf("container_name IN (%s)", strings.Join(placeholders, ", ")))</span>
        }

        // Add search filter if specified
        <span class="cov8" title="1">if params.SearchQuery != "" </span><span class="cov8" title="1">{
                whereConditions = append(whereConditions, "log_message LIKE ? COLLATE NOCASE")
                args = append(args, "%"+params.SearchQuery+"%")
        }</span>

        // Build the final query
        <span class="cov8" title="1">query = "SELECT container_id, container_name, timestamp, stream_type, log_message FROM logs"
        if len(whereConditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " WHERE " + strings.Join(whereConditions, " AND ")
        }</span>
        <span class="cov8" title="1">query += " ORDER BY id DESC LIMIT 101 OFFSET ?"
        args = append(args, params.Offset)

        rows, err := r.db.GetDB().QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("failed to query logs: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var logs []models.LogEntry
        for rows.Next() </span><span class="cov8" title="1">{
                var entry models.LogEntry
                if err := rows.Scan(&amp;entry.ContainerID, &amp;entry.ContainerName, &amp;entry.Timestamp, &amp;entry.StreamType, &amp;entry.LogMessage); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning log row: %v", err)
                        // Skip this row and continue (same as original)
                        continue</span>
                }
                // Truncate long container IDs for display (same as original)
                <span class="cov8" title="1">if len(entry.ContainerID) &gt; 12 </span><span class="cov8" title="1">{
                        entry.ContainerID = entry.ContainerID[:12]
                }</span>
                <span class="cov8" title="1">logs = append(logs, entry)</span>
        }
        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error iterating log rows: %v", err)
                // Still try to return what we have (same as original)
        }</span>

        // Determine if there's a next page (same logic as original)
        <span class="cov8" title="1">hasNext := len(logs) &gt; 100
        if hasNext </span><span class="cov8" title="1">{
                logs = logs[:100] // Remove the extra one for display
        }</span>

        <span class="cov8" title="1">return logs, hasNext, nil</span>
}

// GetContainers fetches distinct container names from the database
// This preserves the exact same logic from the original getAvailableContainers function
func (r *Repository) GetContainers(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        query := "SELECT DISTINCT container_name FROM logs ORDER BY container_name"
        rows, err := r.db.GetDB().QueryContext(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to query container names: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var containers []string
        for rows.Next() </span><span class="cov8" title="1">{
                var containerName string
                if err := rows.Scan(&amp;containerName); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error scanning container name: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">containers = append(containers, containerName)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating container names: %w", err)
        }</span>

        <span class="cov8" title="1">return containers, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "log"

        _ "github.com/mattn/go-sqlite3" // SQLite driver
)

// Database wraps the SQLite database connection
type Database struct {
        db     *sql.DB
        dbPath string
}

// NewDatabase creates a new database connection
func NewDatabase(dbPath string) *Database <span class="cov8" title="1">{
        return &amp;Database{
                dbPath: dbPath,
        }
}</span>

// Connect opens the database connection and initializes the schema
// This preserves the exact same logic from the original initDB() function
func (d *Database) Connect() error <span class="cov8" title="1">{
        var err error
        d.db, err = sql.Open("sqlite3", d.dbPath+"?_busy_timeout=5000") // Added busy_timeout
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open database at %s: %w", d.dbPath, err)
        }</span>

        <span class="cov8" title="1">createTableSQL := `
        CREATE TABLE IF NOT EXISTS logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                container_id TEXT NOT NULL,
                container_name TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                stream_type TEXT NOT NULL, 
                log_message TEXT NOT NULL
        );`

        _, err = d.db.Exec(createTableSQL)
        if err != nil </span><span class="cov8" title="1">{
                d.db.Close()
                return fmt.Errorf("failed to create logs table in %s: %w", d.dbPath, err)
        }</span>

        // Add index on log_message for search performance
        <span class="cov8" title="1">createIndexSQL := `CREATE INDEX IF NOT EXISTS idx_logs_message ON logs(log_message);`
        _, err = d.db.Exec(createIndexSQL)
        if err != nil </span><span class="cov0" title="0">{
                d.db.Close()
                return fmt.Errorf("failed to create index on log_message in %s: %w", d.dbPath, err)
        }</span>

        // Add index on container_name for filtering performance
        <span class="cov8" title="1">createContainerIndexSQL := `CREATE INDEX IF NOT EXISTS idx_logs_container_name ON logs(container_name);`
        _, err = d.db.Exec(createContainerIndexSQL)
        if err != nil </span><span class="cov0" title="0">{
                d.db.Close()
                return fmt.Errorf("failed to create index on container_name in %s: %w", d.dbPath, err)
        }</span>

        <span class="cov8" title="1">log.Printf("Database initialized at %s and logs table ensured.", d.dbPath)
        return nil</span>
}

// Close closes the database connection
func (d *Database) Close() error <span class="cov8" title="1">{
        if d.db != nil </span><span class="cov8" title="1">{
                return d.db.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetDB returns the underlying sql.DB instance
func (d *Database) GetDB() *sql.DB <span class="cov8" title="1">{
        return d.db
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package docker

import (
        "context"
        "log"
        "strings"

        "bw_util/internal/models"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/client"
)

// Client wraps the Docker client
type Client struct {
        client *client.Client
}

// NewClient creates a new Docker client
// This preserves the exact same client creation logic from the original main function
func NewClient() (*Client, error) <span class="cov8" title="1">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Client{client: cli}, nil</span>
}

// ListRunningContainers returns all currently running containers
// This preserves the exact same container listing logic from the original main function
func (c *Client) ListRunningContainers(ctx context.Context) ([]models.Container, error) <span class="cov8" title="1">{
        containers, err := c.client.ContainerList(ctx, container.ListOptions{All: false})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var result []models.Container
        for _, cont := range containers </span><span class="cov8" title="1">{
                containerName := "unknown"
                if len(cont.Names) &gt; 0 </span><span class="cov8" title="1">{
                        containerName = strings.TrimPrefix(cont.Names[0], "/")
                }</span>

                <span class="cov8" title="1">result = append(result, models.Container{
                        ID:    cont.ID,
                        Name:  containerName,
                        Image: cont.Image,
                })</span>
        }

        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                log.Println("No running containers found to monitor.")
        }</span> else<span class="cov8" title="1"> {
                log.Printf("Found %d running containers. Starting log streaming...\n", len(result))
                for _, cont := range result </span><span class="cov8" title="1">{
                        log.Printf("Starting log stream for: ID=%s, Name=%s, Image=%s\n", cont.ID[:12], cont.Name, cont.Image)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetClient returns the underlying Docker client
func (c *Client) GetClient() *client.Client <span class="cov8" title="1">{
        return c.client
}</span>

// Close closes the Docker client connection
func (c *Client) Close() error <span class="cov8" title="1">{
        if c.client != nil </span><span class="cov8" title="1">{
                return c.client.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package docker

import (
        "context"
        "encoding/binary"
        "io"
        "log"
        "sync"
        "time"

        "bw_util/internal/database"
        "bw_util/internal/models"

        "github.com/docker/docker/api/types/container"
)

// Collector manages log collection from multiple containers
type Collector struct {
        client     *Client
        repository database.LogRepository
        wg         sync.WaitGroup
}

// NewCollector creates a new log collector
func NewCollector(client *Client, repository database.LogRepository) *Collector <span class="cov8" title="1">{
        return &amp;Collector{
                client:     client,
                repository: repository,
        }
}</span>

// StartCollection starts log collection for all provided containers
func (c *Collector) StartCollection(ctx context.Context, containers []models.Container) error <span class="cov8" title="1">{
        for _, cont := range containers </span><span class="cov0" title="0">{
                c.wg.Add(1)
                go c.streamAndStoreLogs(ctx, cont.ID, cont.Name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Wait waits for all log streaming goroutines to finish
func (c *Collector) Wait() <span class="cov8" title="1">{
        c.wg.Wait()
}</span>

// streamAndStoreLogs handles fetching, parsing, and storing logs for a single container
// This preserves the exact same logic from the original streamAndStoreLogs function
func (c *Collector) streamAndStoreLogs(ctx context.Context, containerID string, containerName string) <span class="cov0" title="0">{
        defer c.wg.Done() // Decrement counter when goroutine finishes

        // Determine a unique "since" time for this container's log stream to minimize duplicate logs across restarts IF NEEDED.
        // For now, using current time as before, or a very early time to get more history for testing.
        // A more robust approach would be to query the DB for the last timestamp for this containerID.
        sinceTime := time.Now().Add(-30 * time.Minute).Format(time.RFC3339Nano) // Get more history for UI demo

        logOpts := container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
                Follow:     true,
                Timestamps: true,
                Details:    false,
                Since:      sinceTime,
        }

        logReader, err := c.client.GetClient().ContainerLogs(ctx, containerID, logOpts) // Pass cancellable context
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.Canceled </span><span class="cov0" title="0">{
                        log.Printf("Log streaming setup for %s (%s) cancelled during ContainerLogs call.\n", containerName, containerID[:12])
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Error getting logs for container %s (%s): %v\n", containerName, containerID[:12], err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer logReader.Close()

        hdr := make([]byte, 8)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0"> // Check if shutdown has been signaled
                        log.Printf("Shutting down log streaming for %s (%s) due to context cancellation.\n", containerName, containerID[:12])
                        return</span>
                default:<span class="cov0" title="0"></span>
                        // Non-blocking check, proceed with reading logs
                }

                // Set a deadline for the Read operation to make it interruptible by ctx.Done()
                // This is a common pattern but requires the underlying net.Conn if logReader exposes it.
                // For now, the select above is the primary cancellation check point before a potentially blocking Read.
                // A more robust solution might involve a custom reader that respects context cancellation.

                <span class="cov0" title="0">_, err := logReader.Read(hdr)
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"> // If context was cancelled during read
                                log.Printf("Log stream for %s (%s) cancelled during read.\n", containerName, containerID[:12])
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                                log.Printf("Log stream ended (EOF) for container %s (%s)\n", containerName, containerID[:12])
                                return // EOF means the container might have stopped, or logs ended.
                        }</span>
                        <span class="cov0" title="0">log.Printf("Error reading log stream header for %s (%s): %v\n", containerName, containerID[:12], err)
                        return</span> // Return on other errors
                }

                <span class="cov0" title="0">var streamTypeStr string
                switch hdr[0] </span>{
                case 1:<span class="cov0" title="0">
                        streamTypeStr = "stdout"</span>
                case 2:<span class="cov0" title="0">
                        streamTypeStr = "stderr"</span>
                default:<span class="cov0" title="0">
                        payloadSize := binary.BigEndian.Uint32(hdr[4:])
                        if payloadSize &gt; 0 </span><span class="cov0" title="0">{
                                content := make([]byte, payloadSize)
                                _, readErr := io.ReadFull(logReader, content)
                                if readErr != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error reading and discarding unknown stream payload for %s: %v\n", containerName, readErr)
                                        return // Error during discard, exit goroutine for this container
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">payloadSize := binary.BigEndian.Uint32(hdr[4:])
                if payloadSize == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">content := make([]byte, payloadSize)
                _, err = io.ReadFull(logReader, content)
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Printf("Log stream for %s (%s) cancelled during payload read.\n", containerName, containerID[:12])
                                return</span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">log.Printf("Error reading log message payload for %s (%s): %v\n", containerName, containerID[:12], err)
                        return</span> // Error reading payload, exit goroutine for this container
                }

                <span class="cov0" title="0">logMessage := string(content)
                actualTimestampStr, actualLogMessage := ParseLogEntry(logMessage, containerName)

                if actualLogMessage == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Store the log entry using the repository
                <span class="cov0" title="0">entry := &amp;models.LogEntry{
                        ContainerID:   containerID,
                        ContainerName: containerName,
                        Timestamp:     actualTimestampStr,
                        StreamType:    streamTypeStr,
                        LogMessage:    actualLogMessage,
                }

                if err := c.repository.Store(ctx, entry); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to store log entry for %s (%s): %v", containerName, containerID[:12], err)
                        // Continue processing other logs even if one fails
                }</span>
        }
        // log.Printf("Stopped streaming logs for container %s (%s)\n", containerName, containerID[:12]) // This will be logged when loop exits
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package docker

import (
        "strings"
        "time"
)

// ParseLogEntry extracts timestamp and message from a raw log line
// This preserves the exact same parsing logic from the original parseLogEntry function
func ParseLogEntry(logMessage string, containerName string) (timestampStr string, messageStr string) <span class="cov8" title="1">{
        logMessage = strings.TrimRight(logMessage, "\n\r") // Clean trailing newlines first

        firstSpaceIndex := strings.Index(logMessage, " ")
        if firstSpaceIndex &gt; 0 </span><span class="cov8" title="1">{
                timestampCandidate := logMessage[:firstSpaceIndex]
                // Docker's own timestamp format with nanoseconds sometimes has 'Z' and sometimes doesn't directly.
                // time.RFC3339Nano expects 'Z' or a numeric offset.
                // We need to be a bit flexible or ensure Docker consistently provides 'Z'.
                // For now, assuming it's mostly compliant or we fall back.
                parsedTime, err := time.Parse(time.RFC3339Nano, timestampCandidate)
                if err == nil </span><span class="cov8" title="1">{
                        return parsedTime.UTC().Format(time.RFC3339Nano), strings.TrimSpace(logMessage[firstSpaceIndex+1:])
                }</span>
                // Fallback for slightly different formats, e.g. missing 'Z' but otherwise ok (common in some loggers)
                <span class="cov8" title="1">parsedTime, err = time.Parse("2006-01-02T15:04:05.000000000", timestampCandidate) // Example without Z
                if err == nil </span><span class="cov8" title="1">{
                        return parsedTime.UTC().Format(time.RFC3339Nano), strings.TrimSpace(logMessage[firstSpaceIndex+1:])
                }</span>
        }

        // Fallback: If no space or parsing failed, use current time in UTC and the whole message.
        // log.Printf("Debug: Could not parse timestamp from log line for %s. Line: '%s'. Using current time.", containerName, logMessage)
        <span class="cov8" title="1">return time.Now().UTC().Format(time.RFC3339Nano), strings.TrimSpace(logMessage)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package testutil

import (
        "fmt"
        "math/rand"
        "path/filepath"
        "testing"
        "time"

        "bw_util/internal/database"
)

// CreateTempDB creates a temporary database for testing with auto-cleanup
func CreateTempDB(t *testing.T) *database.Database <span class="cov8" title="1">{
        t.Helper()

        // Create a temporary directory
        tempDir := t.TempDir()

        // Generate a random database name
        rand.Seed(time.Now().UnixNano())
        dbName := fmt.Sprintf("test_%d_%d.db", time.Now().Unix(), rand.Intn(10000))
        dbPath := filepath.Join(tempDir, dbName)

        // Create the database
        db := database.NewDatabase(dbPath)

        // Connect and initialize
        if err := db.Connect(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp database: %v", err)
        }</span>

        // Register cleanup
        <span class="cov8" title="1">t.Cleanup(func() </span><span class="cov8" title="1">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        t.Logf("Warning: Failed to close temp database: %v", err)
                }</span>
                // t.TempDir() automatically cleans up the directory
        })

        <span class="cov8" title="1">return db</span>
}

// CreateTempDBPath creates a temporary database path without connecting
func CreateTempDBPath(t *testing.T) string <span class="cov8" title="1">{
        t.Helper()

        tempDir := t.TempDir()
        rand.Seed(time.Now().UnixNano())
        dbName := fmt.Sprintf("test_%d_%d.db", time.Now().Unix(), rand.Intn(10000))
        return filepath.Join(tempDir, dbName)
}</span>

// GetRandomPort returns a random available port for testing
func GetRandomPort() int <span class="cov8" title="1">{
        // Use port 0 to let the OS assign an available port
        // This will be handled by the server implementation
        return 0
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package testutil

import (
        "time"

        "bw_util/internal/models"
)

// SampleLogEntries provides consistent test data for log entries
var SampleLogEntries = []models.LogEntry{
        {
                ContainerID:   "abc123def456789",
                ContainerName: "web-server",
                Timestamp:     "2024-01-01T10:00:00.000000000Z",
                StreamType:    "stdout",
                LogMessage:    "Server started on port 8080",
        },
        {
                ContainerID:   "abc123def456789",
                ContainerName: "web-server",
                Timestamp:     "2024-01-01T10:00:01.123456789Z",
                StreamType:    "stdout",
                LogMessage:    "Listening for connections...",
        },
        {
                ContainerID:   "def456ghi789012",
                ContainerName: "database",
                Timestamp:     "2024-01-01T10:00:02.456789012Z",
                StreamType:    "stdout",
                LogMessage:    "Database connection established",
        },
        {
                ContainerID:   "def456ghi789012",
                ContainerName: "database",
                Timestamp:     "2024-01-01T10:00:03.789012345Z",
                StreamType:    "stderr",
                LogMessage:    "Warning: deprecated configuration option",
        },
        {
                ContainerID:   "ghi789jkl012345",
                ContainerName: "cache-redis",
                Timestamp:     "2024-01-01T10:00:04.012345678Z",
                StreamType:    "stdout",
                LogMessage:    "Redis server started",
        },
}

// SampleContainers provides consistent test data for containers
var SampleContainers = []models.Container{
        {
                ID:    "abc123def456789",
                Name:  "web-server",
                Image: "nginx:latest",
        },
        {
                ID:    "def456ghi789012",
                Name:  "database",
                Image: "postgres:13",
        },
        {
                ID:    "ghi789jkl012345",
                Name:  "cache-redis",
                Image: "redis:alpine",
        },
}

// CreateSampleLogEntry creates a log entry with customizable fields
func CreateSampleLogEntry(containerName, message string) *models.LogEntry <span class="cov8" title="1">{
        return &amp;models.LogEntry{
                ContainerID:   "test123456789",
                ContainerName: containerName,
                Timestamp:     time.Now().Format(time.RFC3339Nano),
                StreamType:    "stdout",
                LogMessage:    message,
        }
}</span>

// CreateSampleContainer creates a container with customizable fields
func CreateSampleContainer(id, name, image string) models.Container <span class="cov8" title="1">{
        return models.Container{
                ID:    id,
                Name:  name,
                Image: image,
        }
}</span>

// SampleSearchParams provides test data for search parameters
var SampleSearchParams = &amp;models.SearchParams{
        SearchQuery:        "server",
        SelectedContainers: []string{"web-server", "database"},
        CurrentPage:        1,
        Offset:             0,
}

// SampleTemplateData provides test data for template rendering
var SampleTemplateData = &amp;models.TemplateData{
        Logs:                SampleLogEntries,
        DBPath:              "/tmp/test.db",
        SearchQuery:         "test query",
        ResultCount:         5,
        HasSearch:           true,
        CurrentPage:         1,
        HasNext:             true,
        HasPrev:             false,
        NextPageURL:         "/?page=2&amp;search=test",
        PrevPageURL:         "",
        AvailableContainers: []string{"web-server", "database", "cache-redis"},
        SelectedContainers:  []string{"web-server"},
        HasContainerFilter:  true,
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package testutil

import (
        "context"
        "errors"
        "io"

        "bw_util/internal/models"
)

// MockDockerClient implements a mock for our Docker client wrapper
type MockDockerClient struct {
        ListRunningContainersFunc func(ctx context.Context) ([]models.Container, error)
        GetClientFunc             func() interface{} // Returns the underlying client
        CloseFunc                 func() error
}

func (m *MockDockerClient) ListRunningContainers(ctx context.Context) ([]models.Container, error) <span class="cov0" title="0">{
        if m.ListRunningContainersFunc != nil </span><span class="cov0" title="0">{
                return m.ListRunningContainersFunc(ctx)
        }</span>
        <span class="cov0" title="0">return []models.Container{}, nil</span>
}

func (m *MockDockerClient) GetClient() interface{} <span class="cov0" title="0">{
        if m.GetClientFunc != nil </span><span class="cov0" title="0">{
                return m.GetClientFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MockDockerClient) Close() error <span class="cov0" title="0">{
        if m.CloseFunc != nil </span><span class="cov0" title="0">{
                return m.CloseFunc()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MockDockerClientError returns a mock that always errors
func NewMockDockerClientError() *MockDockerClient <span class="cov0" title="0">{
        return &amp;MockDockerClient{
                ListRunningContainersFunc: func(ctx context.Context) ([]models.Container, error) </span><span class="cov0" title="0">{
                        return nil, errors.New("docker daemon not available")
                }</span>,
                CloseFunc: func() error <span class="cov0" title="0">{
                        return nil
                }</span>,
        }
}

// MockRepository implements a mock repository for testing
type MockRepository struct {
        StoreFunc         func(ctx context.Context, entry *models.LogEntry) error
        SearchFunc        func(ctx context.Context, params *models.SearchParams) ([]models.LogEntry, bool, error)
        GetContainersFunc func(ctx context.Context) ([]models.Container, error)
}

func (m *MockRepository) Store(ctx context.Context, entry *models.LogEntry) error <span class="cov8" title="1">{
        if m.StoreFunc != nil </span><span class="cov8" title="1">{
                return m.StoreFunc(ctx, entry)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *MockRepository) Search(ctx context.Context, params *models.SearchParams) ([]models.LogEntry, bool, error) <span class="cov8" title="1">{
        if m.SearchFunc != nil </span><span class="cov8" title="1">{
                return m.SearchFunc(ctx, params)
        }</span>
        <span class="cov8" title="1">return []models.LogEntry{}, false, nil</span>
}

func (m *MockRepository) GetContainers(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        if m.GetContainersFunc != nil </span><span class="cov8" title="1">{
                containers, err := m.GetContainersFunc(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Convert []models.Container to []string
                <span class="cov8" title="1">var names []string
                for _, container := range containers </span><span class="cov8" title="1">{
                        names = append(names, container.Name)
                }</span>
                <span class="cov8" title="1">return names, nil</span>
        }
        <span class="cov8" title="1">return []string{}, nil</span>
}

// MockLogReader implements io.ReadCloser for simulating Docker log streams
type MockLogReader struct {
        data   []byte
        pos    int
        closed bool
}

func NewMockLogReader(data string) *MockLogReader <span class="cov8" title="1">{
        return &amp;MockLogReader{
                data: []byte(data),
                pos:  0,
        }
}</span>

func (m *MockLogReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        if m.closed </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>

        <span class="cov8" title="1">if m.pos &gt;= len(m.data) </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>

        <span class="cov8" title="1">n = copy(p, m.data[m.pos:])
        m.pos += n
        return n, nil</span>
}

func (m *MockLogReader) Close() error <span class="cov8" title="1">{
        m.closed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package web

import (
        "log"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "bw_util/internal/database"
        "bw_util/internal/models"
)

// Handler manages HTTP request handling
type Handler struct {
        repository      database.LogRepository
        templateManager *TemplateManager
        dbPath          string
}

// NewHandler creates a new HTTP handler
func NewHandler(repository database.LogRepository, templateManager *TemplateManager, dbPath string) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                repository:      repository,
                templateManager: templateManager,
                dbPath:          dbPath,
        }
}</span>

// ServeLogsPage handles the main logs page request
// This preserves the exact same logic from the original serveLogsPage function
func (h *Handler) ServeLogsPage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get search query parameter
        <span class="cov8" title="1">searchQuery := strings.TrimSpace(r.URL.Query().Get("search"))

        // Get container filter parameter (comma-separated)
        containersParam := strings.TrimSpace(r.URL.Query().Get("containers"))
        var selectedContainers []string
        if containersParam != "" </span><span class="cov8" title="1">{
                // Split by comma and trim spaces
                for _, container := range strings.Split(containersParam, ",") </span><span class="cov8" title="1">{
                        if trimmed := strings.TrimSpace(container); trimmed != "" </span><span class="cov8" title="1">{
                                selectedContainers = append(selectedContainers, trimmed)
                        }</span>
                }
        }

        // Get page parameter (default to 1)
        <span class="cov8" title="1">pageStr := r.URL.Query().Get("page")
        currentPage := 1
        if pageStr != "" </span><span class="cov8" title="1">{
                if parsedPage, err := strconv.Atoi(pageStr); err == nil &amp;&amp; parsedPage &gt;= 1 </span><span class="cov8" title="1">{
                        currentPage = parsedPage
                }</span>
        }

        // Safety limit: max 1000 pages (100K records)
        <span class="cov8" title="1">if currentPage &gt; 1000 </span><span class="cov8" title="1">{
                currentPage = 1000
        }</span>

        // Calculate OFFSET
        <span class="cov8" title="1">offset := (currentPage - 1) * 100

        // Get available containers dynamically
        availableContainers, err := h.repository.GetContainers(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error fetching available containers: %v", err)
                http.Error(w, "Failed to load container list", http.StatusInternalServerError)
                return
        }</span>

        // Search for logs using the repository
        <span class="cov8" title="1">searchParams := &amp;models.SearchParams{
                SearchQuery:        searchQuery,
                SelectedContainers: selectedContainers,
                CurrentPage:        currentPage,
                Offset:             offset,
        }

        logsToDisplay, hasNext, err := h.repository.Search(r.Context(), searchParams)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error querying logs from DB: %v", err)
                http.Error(w, "Failed to retrieve logs", http.StatusInternalServerError)
                return
        }</span>

        // Determine pagination state
        <span class="cov8" title="1">hasPrev := currentPage &gt; 1

        // Build pagination URLs
        nextPageURL := ""
        prevPageURL := ""

        if hasNext </span><span class="cov8" title="1">{
                nextPageURL = h.buildPaginationURL(currentPage+1, searchQuery, selectedContainers)
        }</span>

        <span class="cov8" title="1">if hasPrev </span><span class="cov8" title="1">{
                prevPageURL = h.buildPaginationURL(currentPage-1, searchQuery, selectedContainers)
        }</span>

        // Use a map for data to easily add page title or other elements if needed
        <span class="cov8" title="1">data := &amp;models.TemplateData{
                Logs:                logsToDisplay,
                DBPath:              h.dbPath,
                SearchQuery:         searchQuery,
                ResultCount:         len(logsToDisplay),
                HasSearch:           searchQuery != "",
                CurrentPage:         currentPage,
                HasNext:             hasNext,
                HasPrev:             hasPrev,
                NextPageURL:         nextPageURL,
                PrevPageURL:         prevPageURL,
                AvailableContainers: availableContainers,
                SelectedContainers:  selectedContainers,
                HasContainerFilter:  len(selectedContainers) &gt; 0,
        }

        err = h.templateManager.GetTemplate().ExecuteTemplate(w, "logs.html", data)
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error executing template: %v", err)
                http.Error(w, "Failed to render page", http.StatusInternalServerError)
        }</span>
}

// buildPaginationURL constructs pagination URLs while preserving search parameters
// This preserves the exact same logic from the original buildPaginationURL function
func (h *Handler) buildPaginationURL(page int, searchQuery string, containers []string) string <span class="cov8" title="1">{
        urlStr := "/?page=" + strconv.Itoa(page)
        if searchQuery != "" </span><span class="cov8" title="1">{
                urlStr += "&amp;search=" + url.QueryEscape(searchQuery)
        }</span>
        <span class="cov8" title="1">if len(containers) &gt; 0 </span><span class="cov8" title="1">{
                urlStr += "&amp;containers=" + url.QueryEscape(strings.Join(containers, ","))
        }</span>
        <span class="cov8" title="1">return urlStr</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package web

import (
        "context"
        "log"
        "net/http"
        "time"
)

// Server manages the HTTP web server
type Server struct {
        server  *http.Server
        handler *Handler
}

// NewServer creates a new web server
func NewServer(port string, handler *Handler) *Server <span class="cov8" title="1">{
        mux := http.NewServeMux()
        mux.HandleFunc("/", handler.ServeLogsPage)

        server := &amp;http.Server{
                Addr:    ":" + port,
                Handler: mux,
        }

        return &amp;Server{
                server:  server,
                handler: handler,
        }
}</span>

// Start starts the web server
// This preserves the exact same server startup logic from the original main function
func (s *Server) Start(ctx context.Context) error <span class="cov8" title="1">{
        log.Printf("Starting web UI on http://localhost%s", s.server.Addr)

        go func() </span><span class="cov8" title="1">{
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("ListenAndServe error: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// Shutdown gracefully shuts down the web server
// This preserves the exact same shutdown logic from the original main function
func (s *Server) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        log.Println("Shutting down web server...")
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // Give it 5 seconds to shutdown gracefully
        defer cancel()

        if err := s.server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("HTTP server Shutdown error: %v", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package web

import (
        "embed"
        "fmt"
        "html/template"
        "log"
)

// TemplateManager manages HTML templates
type TemplateManager struct {
        tmpl *template.Template
        fs   embed.FS
}

// NewTemplateManager creates a new template manager
func NewTemplateManager(templatesFS embed.FS) *TemplateManager <span class="cov8" title="1">{
        return &amp;TemplateManager{fs: templatesFS}
}</span>

// LoadTemplates loads HTML templates from embedded filesystem
// This preserves the exact same logic from the original loadTemplates function
func (tm *TemplateManager) LoadTemplates() error <span class="cov8" title="1">{
        var err error
        tm.tmpl, err = template.ParseFS(tm.fs, "templates/*.html")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error parsing templates: %w", err)
        }</span>
        <span class="cov0" title="0">log.Println("HTML templates loaded.")
        return nil</span>
}

// GetTemplate returns the loaded template
func (tm *TemplateManager) GetTemplate() *template.Template <span class="cov8" title="1">{
        return tm.tmpl
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "embed"
        "log"

        "bw_util/internal/app"
)

//go:embed templates
var templatesFS embed.FS

func main() <span class="cov0" title="0">{
        // Create and initialize the application
        application := app.New(templatesFS)

        if err := application.Initialize(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize application: %v", err)
        }</span>

        // Run the application
        <span class="cov0" title="0">if err := application.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Application error: %v", err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
